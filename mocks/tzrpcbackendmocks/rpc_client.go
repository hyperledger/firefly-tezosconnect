// Code generated by mockery v2.23.2. DO NOT EDIT.

package tzrpcbackendmocks

import (
	context "context"

	codec "blockwatch.cc/tzgo/codec"

	http "net/http"

	micheline "blockwatch.cc/tzgo/micheline"

	mock "github.com/stretchr/testify/mock"

	rpc "blockwatch.cc/tzgo/rpc"

	tezos "blockwatch.cc/tzgo/tezos"

	time "time"
)

// RpcClient is an autogenerated mock type for the RpcClient type
type RpcClient struct {
	mock.Mock
}

// BanNetworkPeer provides a mock function with given fields: ctx, peerID
func (_m *RpcClient) BanNetworkPeer(ctx context.Context, peerID string) error {
	ret := _m.Called(ctx, peerID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, peerID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// BanNetworkPoint provides a mock function with given fields: ctx, address
func (_m *RpcClient) BanNetworkPoint(ctx context.Context, address string) error {
	ret := _m.Called(ctx, address)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, address)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Broadcast provides a mock function with given fields: ctx, o
func (_m *RpcClient) Broadcast(ctx context.Context, o *codec.Op) (tezos.OpHash, error) {
	ret := _m.Called(ctx, o)

	var r0 tezos.OpHash
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codec.Op) (tezos.OpHash, error)); ok {
		return rf(ctx, o)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codec.Op) tezos.OpHash); ok {
		r0 = rf(ctx, o)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(tezos.OpHash)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codec.Op) error); ok {
		r1 = rf(ctx, o)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BroadcastOperation provides a mock function with given fields: ctx, body
func (_m *RpcClient) BroadcastOperation(ctx context.Context, body []byte) (tezos.OpHash, error) {
	ret := _m.Called(ctx, body)

	var r0 tezos.OpHash
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []byte) (tezos.OpHash, error)); ok {
		return rf(ctx, body)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []byte) tezos.OpHash); ok {
		r0 = rf(ctx, body)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(tezos.OpHash)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []byte) error); ok {
		r1 = rf(ctx, body)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client provides a mock function with given fields:
func (_m *RpcClient) Client() *http.Client {
	ret := _m.Called()

	var r0 *http.Client
	if rf, ok := ret.Get(0).(func() *http.Client); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Client)
		}
	}

	return r0
}

// Close provides a mock function with given fields:
func (_m *RpcClient) Close() {
	_m.Called()
}

// Complete provides a mock function with given fields: ctx, o, key
func (_m *RpcClient) Complete(ctx context.Context, o *codec.Op, key tezos.Key) error {
	ret := _m.Called(ctx, o, key)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *codec.Op, tezos.Key) error); ok {
		r0 = rf(ctx, o, key)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ConnectToNetworkPoint provides a mock function with given fields: ctx, address, timeout
func (_m *RpcClient) ConnectToNetworkPoint(ctx context.Context, address string, timeout time.Duration) error {
	ret := _m.Called(ctx, address, timeout)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration) error); ok {
		r0 = rf(ctx, address, timeout)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Do provides a mock function with given fields: req, v
func (_m *RpcClient) Do(req *http.Request, v interface{}) error {
	ret := _m.Called(req, v)

	var r0 error
	if rf, ok := ret.Get(0).(func(*http.Request, interface{}) error); ok {
		r0 = rf(req, v)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DoAsync provides a mock function with given fields: req, mon
func (_m *RpcClient) DoAsync(req *http.Request, mon rpc.Monitor) error {
	ret := _m.Called(req, mon)

	var r0 error
	if rf, ok := ret.Get(0).(func(*http.Request, rpc.Monitor) error); ok {
		r0 = rf(req, mon)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ForgeOperation provides a mock function with given fields: ctx, id, body, resp
func (_m *RpcClient) ForgeOperation(ctx context.Context, id rpc.BlockID, body interface{}, resp interface{}) error {
	ret := _m.Called(ctx, id, body, resp)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID, interface{}, interface{}) error); ok {
		r0 = rf(ctx, id, body, resp)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Get provides a mock function with given fields: ctx, urlpath, result
func (_m *RpcClient) Get(ctx context.Context, urlpath string, result interface{}) error {
	ret := _m.Called(ctx, urlpath, result)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) error); ok {
		r0 = rf(ctx, urlpath, result)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetActiveBigmapInfo provides a mock function with given fields: ctx, bigmap
func (_m *RpcClient) GetActiveBigmapInfo(ctx context.Context, bigmap int64) (*rpc.BigmapInfo, error) {
	ret := _m.Called(ctx, bigmap)

	var r0 *rpc.BigmapInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) (*rpc.BigmapInfo, error)); ok {
		return rf(ctx, bigmap)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64) *rpc.BigmapInfo); ok {
		r0 = rf(ctx, bigmap)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpc.BigmapInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = rf(ctx, bigmap)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetActiveBigmapValue provides a mock function with given fields: ctx, bigmap, hash
func (_m *RpcClient) GetActiveBigmapValue(ctx context.Context, bigmap int64, hash tezos.ExprHash) (micheline.Prim, error) {
	ret := _m.Called(ctx, bigmap, hash)

	var r0 micheline.Prim
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, tezos.ExprHash) (micheline.Prim, error)); ok {
		return rf(ctx, bigmap, hash)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, tezos.ExprHash) micheline.Prim); ok {
		r0 = rf(ctx, bigmap, hash)
	} else {
		r0 = ret.Get(0).(micheline.Prim)
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, tezos.ExprHash) error); ok {
		r1 = rf(ctx, bigmap, hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAsync provides a mock function with given fields: ctx, urlpath, mon
func (_m *RpcClient) GetAsync(ctx context.Context, urlpath string, mon rpc.Monitor) error {
	ret := _m.Called(ctx, urlpath, mon)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, rpc.Monitor) error); ok {
		r0 = rf(ctx, urlpath, mon)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetBigmapInfo provides a mock function with given fields: ctx, bigmap, id
func (_m *RpcClient) GetBigmapInfo(ctx context.Context, bigmap int64, id rpc.BlockID) (*rpc.BigmapInfo, error) {
	ret := _m.Called(ctx, bigmap, id)

	var r0 *rpc.BigmapInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, rpc.BlockID) (*rpc.BigmapInfo, error)); ok {
		return rf(ctx, bigmap, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, rpc.BlockID) *rpc.BigmapInfo); ok {
		r0 = rf(ctx, bigmap, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpc.BigmapInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, rpc.BlockID) error); ok {
		r1 = rf(ctx, bigmap, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBigmapValue provides a mock function with given fields: ctx, bigmap, hash, id
func (_m *RpcClient) GetBigmapValue(ctx context.Context, bigmap int64, hash tezos.ExprHash, id rpc.BlockID) (micheline.Prim, error) {
	ret := _m.Called(ctx, bigmap, hash, id)

	var r0 micheline.Prim
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, tezos.ExprHash, rpc.BlockID) (micheline.Prim, error)); ok {
		return rf(ctx, bigmap, hash, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, tezos.ExprHash, rpc.BlockID) micheline.Prim); ok {
		r0 = rf(ctx, bigmap, hash, id)
	} else {
		r0 = ret.Get(0).(micheline.Prim)
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, tezos.ExprHash, rpc.BlockID) error); ok {
		r1 = rf(ctx, bigmap, hash, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlock provides a mock function with given fields: ctx, id
func (_m *RpcClient) GetBlock(ctx context.Context, id rpc.BlockID) (*rpc.Block, error) {
	ret := _m.Called(ctx, id)

	var r0 *rpc.Block
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID) (*rpc.Block, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID) *rpc.Block); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpc.Block)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, rpc.BlockID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockHash provides a mock function with given fields: ctx, id
func (_m *RpcClient) GetBlockHash(ctx context.Context, id rpc.BlockID) (tezos.BlockHash, error) {
	ret := _m.Called(ctx, id)

	var r0 tezos.BlockHash
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID) (tezos.BlockHash, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID) tezos.BlockHash); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(tezos.BlockHash)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, rpc.BlockID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockHeader provides a mock function with given fields: ctx, id
func (_m *RpcClient) GetBlockHeader(ctx context.Context, id rpc.BlockID) (*rpc.BlockHeader, error) {
	ret := _m.Called(ctx, id)

	var r0 *rpc.BlockHeader
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID) (*rpc.BlockHeader, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID) *rpc.BlockHeader); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpc.BlockHeader)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, rpc.BlockID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockHeight provides a mock function with given fields: ctx, height
func (_m *RpcClient) GetBlockHeight(ctx context.Context, height int64) (*rpc.Block, error) {
	ret := _m.Called(ctx, height)

	var r0 *rpc.Block
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) (*rpc.Block, error)); ok {
		return rf(ctx, height)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64) *rpc.Block); ok {
		r0 = rf(ctx, height)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpc.Block)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = rf(ctx, height)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockMetadata provides a mock function with given fields: ctx, id
func (_m *RpcClient) GetBlockMetadata(ctx context.Context, id rpc.BlockID) (*rpc.BlockMetadata, error) {
	ret := _m.Called(ctx, id)

	var r0 *rpc.BlockMetadata
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID) (*rpc.BlockMetadata, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID) *rpc.BlockMetadata); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpc.BlockMetadata)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, rpc.BlockID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockOperation provides a mock function with given fields: ctx, id, l, n
func (_m *RpcClient) GetBlockOperation(ctx context.Context, id rpc.BlockID, l int, n int) (*rpc.Operation, error) {
	ret := _m.Called(ctx, id, l, n)

	var r0 *rpc.Operation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID, int, int) (*rpc.Operation, error)); ok {
		return rf(ctx, id, l, n)
	}
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID, int, int) *rpc.Operation); ok {
		r0 = rf(ctx, id, l, n)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpc.Operation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, rpc.BlockID, int, int) error); ok {
		r1 = rf(ctx, id, l, n)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockOperationHash provides a mock function with given fields: ctx, id, l, n
func (_m *RpcClient) GetBlockOperationHash(ctx context.Context, id rpc.BlockID, l int, n int) (tezos.OpHash, error) {
	ret := _m.Called(ctx, id, l, n)

	var r0 tezos.OpHash
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID, int, int) (tezos.OpHash, error)); ok {
		return rf(ctx, id, l, n)
	}
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID, int, int) tezos.OpHash); ok {
		r0 = rf(ctx, id, l, n)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(tezos.OpHash)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, rpc.BlockID, int, int) error); ok {
		r1 = rf(ctx, id, l, n)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockOperationHashes provides a mock function with given fields: ctx, id
func (_m *RpcClient) GetBlockOperationHashes(ctx context.Context, id rpc.BlockID) ([][]tezos.OpHash, error) {
	ret := _m.Called(ctx, id)

	var r0 [][]tezos.OpHash
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID) ([][]tezos.OpHash, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID) [][]tezos.OpHash); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]tezos.OpHash)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, rpc.BlockID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockOperationList provides a mock function with given fields: ctx, id, l
func (_m *RpcClient) GetBlockOperationList(ctx context.Context, id rpc.BlockID, l int) ([]rpc.Operation, error) {
	ret := _m.Called(ctx, id, l)

	var r0 []rpc.Operation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID, int) ([]rpc.Operation, error)); ok {
		return rf(ctx, id, l)
	}
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID, int) []rpc.Operation); ok {
		r0 = rf(ctx, id, l)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]rpc.Operation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, rpc.BlockID, int) error); ok {
		r1 = rf(ctx, id, l)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockOperationListHashes provides a mock function with given fields: ctx, id, l
func (_m *RpcClient) GetBlockOperationListHashes(ctx context.Context, id rpc.BlockID, l int) ([]tezos.OpHash, error) {
	ret := _m.Called(ctx, id, l)

	var r0 []tezos.OpHash
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID, int) ([]tezos.OpHash, error)); ok {
		return rf(ctx, id, l)
	}
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID, int) []tezos.OpHash); ok {
		r0 = rf(ctx, id, l)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]tezos.OpHash)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, rpc.BlockID, int) error); ok {
		r1 = rf(ctx, id, l)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockOperations provides a mock function with given fields: ctx, id
func (_m *RpcClient) GetBlockOperations(ctx context.Context, id rpc.BlockID) ([][]rpc.Operation, error) {
	ret := _m.Called(ctx, id)

	var r0 [][]rpc.Operation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID) ([][]rpc.Operation, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID) [][]rpc.Operation); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]rpc.Operation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, rpc.BlockID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockPredHashes provides a mock function with given fields: ctx, hash, count
func (_m *RpcClient) GetBlockPredHashes(ctx context.Context, hash tezos.BlockHash, count int) ([]tezos.BlockHash, error) {
	ret := _m.Called(ctx, hash, count)

	var r0 []tezos.BlockHash
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, tezos.BlockHash, int) ([]tezos.BlockHash, error)); ok {
		return rf(ctx, hash, count)
	}
	if rf, ok := ret.Get(0).(func(context.Context, tezos.BlockHash, int) []tezos.BlockHash); ok {
		r0 = rf(ctx, hash, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]tezos.BlockHash)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, tezos.BlockHash, int) error); ok {
		r1 = rf(ctx, hash, count)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetChainId provides a mock function with given fields: ctx
func (_m *RpcClient) GetChainId(ctx context.Context) (tezos.ChainIdHash, error) {
	ret := _m.Called(ctx)

	var r0 tezos.ChainIdHash
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (tezos.ChainIdHash, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) tezos.ChainIdHash); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(tezos.ChainIdHash)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetConstants provides a mock function with given fields: ctx, id
func (_m *RpcClient) GetConstants(ctx context.Context, id rpc.BlockID) (rpc.Constants, error) {
	ret := _m.Called(ctx, id)

	var r0 rpc.Constants
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID) (rpc.Constants, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID) rpc.Constants); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Get(0).(rpc.Constants)
	}

	if rf, ok := ret.Get(1).(func(context.Context, rpc.BlockID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetContract provides a mock function with given fields: ctx, addr, id
func (_m *RpcClient) GetContract(ctx context.Context, addr tezos.Address, id rpc.BlockID) (*rpc.ContractInfo, error) {
	ret := _m.Called(ctx, addr, id)

	var r0 *rpc.ContractInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, tezos.Address, rpc.BlockID) (*rpc.ContractInfo, error)); ok {
		return rf(ctx, addr, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, tezos.Address, rpc.BlockID) *rpc.ContractInfo); ok {
		r0 = rf(ctx, addr, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpc.ContractInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, tezos.Address, rpc.BlockID) error); ok {
		r1 = rf(ctx, addr, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetContractBalance provides a mock function with given fields: ctx, addr, id
func (_m *RpcClient) GetContractBalance(ctx context.Context, addr tezos.Address, id rpc.BlockID) (tezos.Z, error) {
	ret := _m.Called(ctx, addr, id)

	var r0 tezos.Z
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, tezos.Address, rpc.BlockID) (tezos.Z, error)); ok {
		return rf(ctx, addr, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, tezos.Address, rpc.BlockID) tezos.Z); ok {
		r0 = rf(ctx, addr, id)
	} else {
		r0 = ret.Get(0).(tezos.Z)
	}

	if rf, ok := ret.Get(1).(func(context.Context, tezos.Address, rpc.BlockID) error); ok {
		r1 = rf(ctx, addr, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetContractEntrypoints provides a mock function with given fields: ctx, addr
func (_m *RpcClient) GetContractEntrypoints(ctx context.Context, addr tezos.Address) (map[string]micheline.Type, error) {
	ret := _m.Called(ctx, addr)

	var r0 map[string]micheline.Type
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, tezos.Address) (map[string]micheline.Type, error)); ok {
		return rf(ctx, addr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, tezos.Address) map[string]micheline.Type); ok {
		r0 = rf(ctx, addr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]micheline.Type)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, tezos.Address) error); ok {
		r1 = rf(ctx, addr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetContractExt provides a mock function with given fields: ctx, addr, id
func (_m *RpcClient) GetContractExt(ctx context.Context, addr tezos.Address, id rpc.BlockID) (*rpc.ContractInfo, error) {
	ret := _m.Called(ctx, addr, id)

	var r0 *rpc.ContractInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, tezos.Address, rpc.BlockID) (*rpc.ContractInfo, error)); ok {
		return rf(ctx, addr, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, tezos.Address, rpc.BlockID) *rpc.ContractInfo); ok {
		r0 = rf(ctx, addr, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpc.ContractInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, tezos.Address, rpc.BlockID) error); ok {
		r1 = rf(ctx, addr, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetContractScript provides a mock function with given fields: ctx, addr
func (_m *RpcClient) GetContractScript(ctx context.Context, addr tezos.Address) (*micheline.Script, error) {
	ret := _m.Called(ctx, addr)

	var r0 *micheline.Script
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, tezos.Address) (*micheline.Script, error)); ok {
		return rf(ctx, addr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, tezos.Address) *micheline.Script); ok {
		r0 = rf(ctx, addr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*micheline.Script)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, tezos.Address) error); ok {
		r1 = rf(ctx, addr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetContractStorage provides a mock function with given fields: ctx, addr, id
func (_m *RpcClient) GetContractStorage(ctx context.Context, addr tezos.Address, id rpc.BlockID) (micheline.Prim, error) {
	ret := _m.Called(ctx, addr, id)

	var r0 micheline.Prim
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, tezos.Address, rpc.BlockID) (micheline.Prim, error)); ok {
		return rf(ctx, addr, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, tezos.Address, rpc.BlockID) micheline.Prim); ok {
		r0 = rf(ctx, addr, id)
	} else {
		r0 = ret.Get(0).(micheline.Prim)
	}

	if rf, ok := ret.Get(1).(func(context.Context, tezos.Address, rpc.BlockID) error); ok {
		r1 = rf(ctx, addr, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetContractStorageNormalized provides a mock function with given fields: ctx, addr, id, mode
func (_m *RpcClient) GetContractStorageNormalized(ctx context.Context, addr tezos.Address, id rpc.BlockID, mode rpc.UnparsingMode) (micheline.Prim, error) {
	ret := _m.Called(ctx, addr, id, mode)

	var r0 micheline.Prim
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, tezos.Address, rpc.BlockID, rpc.UnparsingMode) (micheline.Prim, error)); ok {
		return rf(ctx, addr, id, mode)
	}
	if rf, ok := ret.Get(0).(func(context.Context, tezos.Address, rpc.BlockID, rpc.UnparsingMode) micheline.Prim); ok {
		r0 = rf(ctx, addr, id, mode)
	} else {
		r0 = ret.Get(0).(micheline.Prim)
	}

	if rf, ok := ret.Get(1).(func(context.Context, tezos.Address, rpc.BlockID, rpc.UnparsingMode) error); ok {
		r1 = rf(ctx, addr, id, mode)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCustomConstants provides a mock function with given fields: ctx, id, resp
func (_m *RpcClient) GetCustomConstants(ctx context.Context, id rpc.BlockID, resp interface{}) error {
	ret := _m.Called(ctx, id, resp)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID, interface{}) error); ok {
		r0 = rf(ctx, id, resp)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetDelegate provides a mock function with given fields: ctx, addr, id
func (_m *RpcClient) GetDelegate(ctx context.Context, addr tezos.Address, id rpc.BlockID) (*rpc.Delegate, error) {
	ret := _m.Called(ctx, addr, id)

	var r0 *rpc.Delegate
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, tezos.Address, rpc.BlockID) (*rpc.Delegate, error)); ok {
		return rf(ctx, addr, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, tezos.Address, rpc.BlockID) *rpc.Delegate); ok {
		r0 = rf(ctx, addr, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpc.Delegate)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, tezos.Address, rpc.BlockID) error); ok {
		r1 = rf(ctx, addr, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDelegateBalance provides a mock function with given fields: ctx, addr, id
func (_m *RpcClient) GetDelegateBalance(ctx context.Context, addr tezos.Address, id rpc.BlockID) (int64, error) {
	ret := _m.Called(ctx, addr, id)

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, tezos.Address, rpc.BlockID) (int64, error)); ok {
		return rf(ctx, addr, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, tezos.Address, rpc.BlockID) int64); ok {
		r0 = rf(ctx, addr, id)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, tezos.Address, rpc.BlockID) error); ok {
		r1 = rf(ctx, addr, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetGenesisBlock provides a mock function with given fields: ctx
func (_m *RpcClient) GetGenesisBlock(ctx context.Context) (*rpc.Block, error) {
	ret := _m.Called(ctx)

	var r0 *rpc.Block
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*rpc.Block, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *rpc.Block); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpc.Block)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetHeadBlock provides a mock function with given fields: ctx
func (_m *RpcClient) GetHeadBlock(ctx context.Context) (*rpc.Block, error) {
	ret := _m.Called(ctx)

	var r0 *rpc.Block
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*rpc.Block, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *rpc.Block); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpc.Block)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetInvalidBlock provides a mock function with given fields: ctx, blockID
func (_m *RpcClient) GetInvalidBlock(ctx context.Context, blockID tezos.BlockHash) (*rpc.InvalidBlock, error) {
	ret := _m.Called(ctx, blockID)

	var r0 *rpc.InvalidBlock
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, tezos.BlockHash) (*rpc.InvalidBlock, error)); ok {
		return rf(ctx, blockID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, tezos.BlockHash) *rpc.InvalidBlock); ok {
		r0 = rf(ctx, blockID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpc.InvalidBlock)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, tezos.BlockHash) error); ok {
		r1 = rf(ctx, blockID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetInvalidBlocks provides a mock function with given fields: ctx
func (_m *RpcClient) GetInvalidBlocks(ctx context.Context) ([]*rpc.InvalidBlock, error) {
	ret := _m.Called(ctx)

	var r0 []*rpc.InvalidBlock
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]*rpc.InvalidBlock, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []*rpc.InvalidBlock); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*rpc.InvalidBlock)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetManagerKey provides a mock function with given fields: ctx, addr, id
func (_m *RpcClient) GetManagerKey(ctx context.Context, addr tezos.Address, id rpc.BlockID) (tezos.Key, error) {
	ret := _m.Called(ctx, addr, id)

	var r0 tezos.Key
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, tezos.Address, rpc.BlockID) (tezos.Key, error)); ok {
		return rf(ctx, addr, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, tezos.Address, rpc.BlockID) tezos.Key); ok {
		r0 = rf(ctx, addr, id)
	} else {
		r0 = ret.Get(0).(tezos.Key)
	}

	if rf, ok := ret.Get(1).(func(context.Context, tezos.Address, rpc.BlockID) error); ok {
		r1 = rf(ctx, addr, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMempool provides a mock function with given fields: ctx
func (_m *RpcClient) GetMempool(ctx context.Context) (*rpc.Mempool, error) {
	ret := _m.Called(ctx)

	var r0 *rpc.Mempool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*rpc.Mempool, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *rpc.Mempool); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpc.Mempool)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNetworkConnections provides a mock function with given fields: ctx
func (_m *RpcClient) GetNetworkConnections(ctx context.Context) ([]*rpc.NetworkConnection, error) {
	ret := _m.Called(ctx)

	var r0 []*rpc.NetworkConnection
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]*rpc.NetworkConnection, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []*rpc.NetworkConnection); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*rpc.NetworkConnection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNetworkPeer provides a mock function with given fields: ctx, peerID
func (_m *RpcClient) GetNetworkPeer(ctx context.Context, peerID string) (*rpc.NetworkPeer, error) {
	ret := _m.Called(ctx, peerID)

	var r0 *rpc.NetworkPeer
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*rpc.NetworkPeer, error)); ok {
		return rf(ctx, peerID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *rpc.NetworkPeer); ok {
		r0 = rf(ctx, peerID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpc.NetworkPeer)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, peerID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNetworkPeerBanned provides a mock function with given fields: ctx, peerID
func (_m *RpcClient) GetNetworkPeerBanned(ctx context.Context, peerID string) (bool, error) {
	ret := _m.Called(ctx, peerID)

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (bool, error)); ok {
		return rf(ctx, peerID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) bool); ok {
		r0 = rf(ctx, peerID)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, peerID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNetworkPeerLog provides a mock function with given fields: ctx, peerID
func (_m *RpcClient) GetNetworkPeerLog(ctx context.Context, peerID string) ([]*rpc.NetworkPeerLogEntry, error) {
	ret := _m.Called(ctx, peerID)

	var r0 []*rpc.NetworkPeerLogEntry
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]*rpc.NetworkPeerLogEntry, error)); ok {
		return rf(ctx, peerID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []*rpc.NetworkPeerLogEntry); ok {
		r0 = rf(ctx, peerID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*rpc.NetworkPeerLogEntry)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, peerID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNetworkPeers provides a mock function with given fields: ctx, filter
func (_m *RpcClient) GetNetworkPeers(ctx context.Context, filter string) ([]*rpc.NetworkPeer, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*rpc.NetworkPeer
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]*rpc.NetworkPeer, error)); ok {
		return rf(ctx, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []*rpc.NetworkPeer); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*rpc.NetworkPeer)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, filter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNetworkPoint provides a mock function with given fields: ctx, address
func (_m *RpcClient) GetNetworkPoint(ctx context.Context, address string) (*rpc.NetworkPoint, error) {
	ret := _m.Called(ctx, address)

	var r0 *rpc.NetworkPoint
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*rpc.NetworkPoint, error)); ok {
		return rf(ctx, address)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *rpc.NetworkPoint); ok {
		r0 = rf(ctx, address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpc.NetworkPoint)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNetworkPointBanned provides a mock function with given fields: ctx, address
func (_m *RpcClient) GetNetworkPointBanned(ctx context.Context, address string) (bool, error) {
	ret := _m.Called(ctx, address)

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (bool, error)); ok {
		return rf(ctx, address)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) bool); ok {
		r0 = rf(ctx, address)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNetworkPointLog provides a mock function with given fields: ctx, address
func (_m *RpcClient) GetNetworkPointLog(ctx context.Context, address string) ([]*rpc.NetworkPointLogEntry, error) {
	ret := _m.Called(ctx, address)

	var r0 []*rpc.NetworkPointLogEntry
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]*rpc.NetworkPointLogEntry, error)); ok {
		return rf(ctx, address)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []*rpc.NetworkPointLogEntry); ok {
		r0 = rf(ctx, address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*rpc.NetworkPointLogEntry)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNetworkPoints provides a mock function with given fields: ctx, filter
func (_m *RpcClient) GetNetworkPoints(ctx context.Context, filter string) ([]*rpc.NetworkPoint, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*rpc.NetworkPoint
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]*rpc.NetworkPoint, error)); ok {
		return rf(ctx, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []*rpc.NetworkPoint); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*rpc.NetworkPoint)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, filter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNetworkStats provides a mock function with given fields: ctx
func (_m *RpcClient) GetNetworkStats(ctx context.Context) (*rpc.NetworkStats, error) {
	ret := _m.Called(ctx)

	var r0 *rpc.NetworkStats
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*rpc.NetworkStats, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *rpc.NetworkStats); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpc.NetworkStats)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNormalizedScript provides a mock function with given fields: ctx, addr, mode
func (_m *RpcClient) GetNormalizedScript(ctx context.Context, addr tezos.Address, mode rpc.UnparsingMode) (*micheline.Script, error) {
	ret := _m.Called(ctx, addr, mode)

	var r0 *micheline.Script
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, tezos.Address, rpc.UnparsingMode) (*micheline.Script, error)); ok {
		return rf(ctx, addr, mode)
	}
	if rf, ok := ret.Get(0).(func(context.Context, tezos.Address, rpc.UnparsingMode) *micheline.Script); ok {
		r0 = rf(ctx, addr, mode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*micheline.Script)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, tezos.Address, rpc.UnparsingMode) error); ok {
		r1 = rf(ctx, addr, mode)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetParams provides a mock function with given fields: ctx, id
func (_m *RpcClient) GetParams(ctx context.Context, id rpc.BlockID) (*tezos.Params, error) {
	ret := _m.Called(ctx, id)

	var r0 *tezos.Params
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID) (*tezos.Params, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID) *tezos.Params); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*tezos.Params)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, rpc.BlockID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRollSnapshotInfoCycle provides a mock function with given fields: ctx, id, cycle
func (_m *RpcClient) GetRollSnapshotInfoCycle(ctx context.Context, id rpc.BlockID, cycle int64) (*rpc.RollSnapshotInfo, error) {
	ret := _m.Called(ctx, id, cycle)

	var r0 *rpc.RollSnapshotInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID, int64) (*rpc.RollSnapshotInfo, error)); ok {
		return rf(ctx, id, cycle)
	}
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID, int64) *rpc.RollSnapshotInfo); ok {
		r0 = rf(ctx, id, cycle)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpc.RollSnapshotInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, rpc.BlockID, int64) error); ok {
		r1 = rf(ctx, id, cycle)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSnapshotIndexCycle provides a mock function with given fields: ctx, id, cycle
func (_m *RpcClient) GetSnapshotIndexCycle(ctx context.Context, id rpc.BlockID, cycle int64) (*rpc.SnapshotIndex, error) {
	ret := _m.Called(ctx, id, cycle)

	var r0 *rpc.SnapshotIndex
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID, int64) (*rpc.SnapshotIndex, error)); ok {
		return rf(ctx, id, cycle)
	}
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID, int64) *rpc.SnapshotIndex); ok {
		r0 = rf(ctx, id, cycle)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpc.SnapshotIndex)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, rpc.BlockID, int64) error); ok {
		r1 = rf(ctx, id, cycle)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetStakingSnapshotInfoCycle provides a mock function with given fields: ctx, id, cycle
func (_m *RpcClient) GetStakingSnapshotInfoCycle(ctx context.Context, id rpc.BlockID, cycle int64) (*rpc.StakingSnapshotInfo, error) {
	ret := _m.Called(ctx, id, cycle)

	var r0 *rpc.StakingSnapshotInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID, int64) (*rpc.StakingSnapshotInfo, error)); ok {
		return rf(ctx, id, cycle)
	}
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID, int64) *rpc.StakingSnapshotInfo); ok {
		r0 = rf(ctx, id, cycle)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpc.StakingSnapshotInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, rpc.BlockID, int64) error); ok {
		r1 = rf(ctx, id, cycle)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetStatus provides a mock function with given fields: ctx
func (_m *RpcClient) GetStatus(ctx context.Context) (rpc.Status, error) {
	ret := _m.Called(ctx)

	var r0 rpc.Status
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (rpc.Status, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) rpc.Status); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(rpc.Status)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTipHeader provides a mock function with given fields: ctx
func (_m *RpcClient) GetTipHeader(ctx context.Context) (*rpc.BlockHeader, error) {
	ret := _m.Called(ctx)

	var r0 *rpc.BlockHeader
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*rpc.BlockHeader, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *rpc.BlockHeader); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpc.BlockHeader)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTips provides a mock function with given fields: ctx, depth, head
func (_m *RpcClient) GetTips(ctx context.Context, depth int, head tezos.BlockHash) ([][]tezos.BlockHash, error) {
	ret := _m.Called(ctx, depth, head)

	var r0 [][]tezos.BlockHash
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, tezos.BlockHash) ([][]tezos.BlockHash, error)); ok {
		return rf(ctx, depth, head)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, tezos.BlockHash) [][]tezos.BlockHash); ok {
		r0 = rf(ctx, depth, head)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]tezos.BlockHash)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, tezos.BlockHash) error); ok {
		r1 = rf(ctx, depth, head)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetVersionInfo provides a mock function with given fields: ctx
func (_m *RpcClient) GetVersionInfo(ctx context.Context) (rpc.VersionInfo, error) {
	ret := _m.Called(ctx)

	var r0 rpc.VersionInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (rpc.VersionInfo, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) rpc.VersionInfo); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(rpc.VersionInfo)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetVoteProposal provides a mock function with given fields: ctx, id
func (_m *RpcClient) GetVoteProposal(ctx context.Context, id rpc.BlockID) (tezos.ProtocolHash, error) {
	ret := _m.Called(ctx, id)

	var r0 tezos.ProtocolHash
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID) (tezos.ProtocolHash, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID) tezos.ProtocolHash); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(tezos.ProtocolHash)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, rpc.BlockID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetVoteQuorum provides a mock function with given fields: ctx, id
func (_m *RpcClient) GetVoteQuorum(ctx context.Context, id rpc.BlockID) (int, error) {
	ret := _m.Called(ctx, id)

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID) (int, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID) int); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context, rpc.BlockID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetVoteResult provides a mock function with given fields: ctx, id
func (_m *RpcClient) GetVoteResult(ctx context.Context, id rpc.BlockID) (rpc.BallotSummary, error) {
	ret := _m.Called(ctx, id)

	var r0 rpc.BallotSummary
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID) (rpc.BallotSummary, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID) rpc.BallotSummary); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Get(0).(rpc.BallotSummary)
	}

	if rf, ok := ret.Get(1).(func(context.Context, rpc.BlockID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Init provides a mock function with given fields: ctx
func (_m *RpcClient) Init(ctx context.Context) error {
	ret := _m.Called(ctx)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ListActiveBigmapKeys provides a mock function with given fields: ctx, bigmap
func (_m *RpcClient) ListActiveBigmapKeys(ctx context.Context, bigmap int64) ([]tezos.ExprHash, error) {
	ret := _m.Called(ctx, bigmap)

	var r0 []tezos.ExprHash
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) ([]tezos.ExprHash, error)); ok {
		return rf(ctx, bigmap)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64) []tezos.ExprHash); ok {
		r0 = rf(ctx, bigmap)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]tezos.ExprHash)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = rf(ctx, bigmap)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListActiveBigmapValues provides a mock function with given fields: ctx, bigmap, id
func (_m *RpcClient) ListActiveBigmapValues(ctx context.Context, bigmap int64, id rpc.BlockID) ([]micheline.Prim, error) {
	ret := _m.Called(ctx, bigmap, id)

	var r0 []micheline.Prim
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, rpc.BlockID) ([]micheline.Prim, error)); ok {
		return rf(ctx, bigmap, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, rpc.BlockID) []micheline.Prim); ok {
		r0 = rf(ctx, bigmap, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]micheline.Prim)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, rpc.BlockID) error); ok {
		r1 = rf(ctx, bigmap, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListActiveDelegates provides a mock function with given fields: ctx, id
func (_m *RpcClient) ListActiveDelegates(ctx context.Context, id rpc.BlockID) (rpc.DelegateList, error) {
	ret := _m.Called(ctx, id)

	var r0 rpc.DelegateList
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID) (rpc.DelegateList, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID) rpc.DelegateList); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(rpc.DelegateList)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, rpc.BlockID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBakingRights provides a mock function with given fields: ctx, id, max
func (_m *RpcClient) ListBakingRights(ctx context.Context, id rpc.BlockID, max int) ([]rpc.BakingRight, error) {
	ret := _m.Called(ctx, id, max)

	var r0 []rpc.BakingRight
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID, int) ([]rpc.BakingRight, error)); ok {
		return rf(ctx, id, max)
	}
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID, int) []rpc.BakingRight); ok {
		r0 = rf(ctx, id, max)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]rpc.BakingRight)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, rpc.BlockID, int) error); ok {
		r1 = rf(ctx, id, max)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBakingRightsCycle provides a mock function with given fields: ctx, id, cycle, max
func (_m *RpcClient) ListBakingRightsCycle(ctx context.Context, id rpc.BlockID, cycle int64, max int) ([]rpc.BakingRight, error) {
	ret := _m.Called(ctx, id, cycle, max)

	var r0 []rpc.BakingRight
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID, int64, int) ([]rpc.BakingRight, error)); ok {
		return rf(ctx, id, cycle, max)
	}
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID, int64, int) []rpc.BakingRight); ok {
		r0 = rf(ctx, id, cycle, max)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]rpc.BakingRight)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, rpc.BlockID, int64, int) error); ok {
		r1 = rf(ctx, id, cycle, max)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBallots provides a mock function with given fields: ctx, id
func (_m *RpcClient) ListBallots(ctx context.Context, id rpc.BlockID) (rpc.BallotList, error) {
	ret := _m.Called(ctx, id)

	var r0 rpc.BallotList
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID) (rpc.BallotList, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID) rpc.BallotList); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(rpc.BallotList)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, rpc.BlockID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBigmapKeys provides a mock function with given fields: ctx, bigmap, id
func (_m *RpcClient) ListBigmapKeys(ctx context.Context, bigmap int64, id rpc.BlockID) ([]tezos.ExprHash, error) {
	ret := _m.Called(ctx, bigmap, id)

	var r0 []tezos.ExprHash
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, rpc.BlockID) ([]tezos.ExprHash, error)); ok {
		return rf(ctx, bigmap, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, rpc.BlockID) []tezos.ExprHash); ok {
		r0 = rf(ctx, bigmap, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]tezos.ExprHash)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, rpc.BlockID) error); ok {
		r1 = rf(ctx, bigmap, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBigmapValues provides a mock function with given fields: ctx, bigmap, id
func (_m *RpcClient) ListBigmapValues(ctx context.Context, bigmap int64, id rpc.BlockID) ([]micheline.Prim, error) {
	ret := _m.Called(ctx, bigmap, id)

	var r0 []micheline.Prim
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, rpc.BlockID) ([]micheline.Prim, error)); ok {
		return rf(ctx, bigmap, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, rpc.BlockID) []micheline.Prim); ok {
		r0 = rf(ctx, bigmap, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]micheline.Prim)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, rpc.BlockID) error); ok {
		r1 = rf(ctx, bigmap, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListContracts provides a mock function with given fields: ctx, id
func (_m *RpcClient) ListContracts(ctx context.Context, id rpc.BlockID) (rpc.Contracts, error) {
	ret := _m.Called(ctx, id)

	var r0 rpc.Contracts
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID) (rpc.Contracts, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID) rpc.Contracts); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(rpc.Contracts)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, rpc.BlockID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListEndorsingRights provides a mock function with given fields: ctx, id
func (_m *RpcClient) ListEndorsingRights(ctx context.Context, id rpc.BlockID) ([]rpc.EndorsingRight, error) {
	ret := _m.Called(ctx, id)

	var r0 []rpc.EndorsingRight
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID) ([]rpc.EndorsingRight, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID) []rpc.EndorsingRight); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]rpc.EndorsingRight)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, rpc.BlockID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListEndorsingRightsCycle provides a mock function with given fields: ctx, id, cycle
func (_m *RpcClient) ListEndorsingRightsCycle(ctx context.Context, id rpc.BlockID, cycle int64) ([]rpc.EndorsingRight, error) {
	ret := _m.Called(ctx, id, cycle)

	var r0 []rpc.EndorsingRight
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID, int64) ([]rpc.EndorsingRight, error)); ok {
		return rf(ctx, id, cycle)
	}
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID, int64) []rpc.EndorsingRight); ok {
		r0 = rf(ctx, id, cycle)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]rpc.EndorsingRight)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, rpc.BlockID, int64) error); ok {
		r1 = rf(ctx, id, cycle)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListProposals provides a mock function with given fields: ctx, id
func (_m *RpcClient) ListProposals(ctx context.Context, id rpc.BlockID) (rpc.ProposalList, error) {
	ret := _m.Called(ctx, id)

	var r0 rpc.ProposalList
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID) (rpc.ProposalList, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID) rpc.ProposalList); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(rpc.ProposalList)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, rpc.BlockID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSnapshotRollOwners provides a mock function with given fields: ctx, id, cycle, index
func (_m *RpcClient) ListSnapshotRollOwners(ctx context.Context, id rpc.BlockID, cycle int64, index int64) (*rpc.SnapshotOwners, error) {
	ret := _m.Called(ctx, id, cycle, index)

	var r0 *rpc.SnapshotOwners
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID, int64, int64) (*rpc.SnapshotOwners, error)); ok {
		return rf(ctx, id, cycle, index)
	}
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID, int64, int64) *rpc.SnapshotOwners); ok {
		r0 = rf(ctx, id, cycle, index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpc.SnapshotOwners)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, rpc.BlockID, int64, int64) error); ok {
		r1 = rf(ctx, id, cycle, index)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListVoters provides a mock function with given fields: ctx, id
func (_m *RpcClient) ListVoters(ctx context.Context, id rpc.BlockID) (rpc.VoterList, error) {
	ret := _m.Called(ctx, id)

	var r0 rpc.VoterList
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID) (rpc.VoterList, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID) rpc.VoterList); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(rpc.VoterList)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, rpc.BlockID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Listen provides a mock function with given fields:
func (_m *RpcClient) Listen() {
	_m.Called()
}

// MonitorBlockHeader provides a mock function with given fields: ctx, monitor
func (_m *RpcClient) MonitorBlockHeader(ctx context.Context, monitor *rpc.BlockHeaderMonitor) error {
	ret := _m.Called(ctx, monitor)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *rpc.BlockHeaderMonitor) error); ok {
		r0 = rf(ctx, monitor)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MonitorBootstrapped provides a mock function with given fields: ctx, monitor
func (_m *RpcClient) MonitorBootstrapped(ctx context.Context, monitor *rpc.BootstrapMonitor) error {
	ret := _m.Called(ctx, monitor)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *rpc.BootstrapMonitor) error); ok {
		r0 = rf(ctx, monitor)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MonitorMempool provides a mock function with given fields: ctx, monitor
func (_m *RpcClient) MonitorMempool(ctx context.Context, monitor *rpc.MempoolMonitor) error {
	ret := _m.Called(ctx, monitor)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *rpc.MempoolMonitor) error); ok {
		r0 = rf(ctx, monitor)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MonitorNetworkPeerLog provides a mock function with given fields: ctx, peerID, monitor
func (_m *RpcClient) MonitorNetworkPeerLog(ctx context.Context, peerID string, monitor *rpc.NetworkPeerMonitor) error {
	ret := _m.Called(ctx, peerID, monitor)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *rpc.NetworkPeerMonitor) error); ok {
		r0 = rf(ctx, peerID, monitor)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MonitorNetworkPointLog provides a mock function with given fields: ctx, address, monitor
func (_m *RpcClient) MonitorNetworkPointLog(ctx context.Context, address string, monitor *rpc.NetworkPointMonitor) error {
	ret := _m.Called(ctx, address, monitor)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *rpc.NetworkPointMonitor) error); ok {
		r0 = rf(ctx, address, monitor)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewRequest provides a mock function with given fields: ctx, method, urlStr, body
func (_m *RpcClient) NewRequest(ctx context.Context, method string, urlStr string, body interface{}) (*http.Request, error) {
	ret := _m.Called(ctx, method, urlStr, body)

	var r0 *http.Request
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, interface{}) (*http.Request, error)); ok {
		return rf(ctx, method, urlStr, body)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, interface{}) *http.Request); ok {
		r0 = rf(ctx, method, urlStr, body)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Request)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, interface{}) error); ok {
		r1 = rf(ctx, method, urlStr, body)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Post provides a mock function with given fields: ctx, urlpath, body, result
func (_m *RpcClient) Post(ctx context.Context, urlpath string, body interface{}, result interface{}) error {
	ret := _m.Called(ctx, urlpath, body, result)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, interface{}) error); ok {
		r0 = rf(ctx, urlpath, body, result)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Put provides a mock function with given fields: ctx, urlpath, body, result
func (_m *RpcClient) Put(ctx context.Context, urlpath string, body interface{}, result interface{}) error {
	ret := _m.Called(ctx, urlpath, body, result)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, interface{}) error); ok {
		r0 = rf(ctx, urlpath, body, result)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ResolveChainConfig provides a mock function with given fields: ctx
func (_m *RpcClient) ResolveChainConfig(ctx context.Context) error {
	ret := _m.Called(ctx)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RunCallback provides a mock function with given fields: ctx, id, body, resp
func (_m *RpcClient) RunCallback(ctx context.Context, id rpc.BlockID, body interface{}, resp interface{}) error {
	ret := _m.Called(ctx, id, body, resp)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID, interface{}, interface{}) error); ok {
		r0 = rf(ctx, id, body, resp)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RunCode provides a mock function with given fields: ctx, id, body, resp
func (_m *RpcClient) RunCode(ctx context.Context, id rpc.BlockID, body interface{}, resp interface{}) error {
	ret := _m.Called(ctx, id, body, resp)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID, interface{}, interface{}) error); ok {
		r0 = rf(ctx, id, body, resp)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RunOperation provides a mock function with given fields: ctx, id, body, resp
func (_m *RpcClient) RunOperation(ctx context.Context, id rpc.BlockID, body interface{}, resp interface{}) error {
	ret := _m.Called(ctx, id, body, resp)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID, interface{}, interface{}) error); ok {
		r0 = rf(ctx, id, body, resp)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RunView provides a mock function with given fields: ctx, id, body, resp
func (_m *RpcClient) RunView(ctx context.Context, id rpc.BlockID, body interface{}, resp interface{}) error {
	ret := _m.Called(ctx, id, body, resp)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID, interface{}, interface{}) error); ok {
		r0 = rf(ctx, id, body, resp)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Send provides a mock function with given fields: ctx, op, opts
func (_m *RpcClient) Send(ctx context.Context, op *codec.Op, opts *rpc.CallOptions) (*rpc.Receipt, error) {
	ret := _m.Called(ctx, op, opts)

	var r0 *rpc.Receipt
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codec.Op, *rpc.CallOptions) (*rpc.Receipt, error)); ok {
		return rf(ctx, op, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codec.Op, *rpc.CallOptions) *rpc.Receipt); ok {
		r0 = rf(ctx, op, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpc.Receipt)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codec.Op, *rpc.CallOptions) error); ok {
		r1 = rf(ctx, op, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Simulate provides a mock function with given fields: ctx, o, opts
func (_m *RpcClient) Simulate(ctx context.Context, o *codec.Op, opts *rpc.CallOptions) (*rpc.Receipt, error) {
	ret := _m.Called(ctx, o, opts)

	var r0 *rpc.Receipt
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *codec.Op, *rpc.CallOptions) (*rpc.Receipt, error)); ok {
		return rf(ctx, o, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *codec.Op, *rpc.CallOptions) *rpc.Receipt); ok {
		r0 = rf(ctx, o, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpc.Receipt)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *codec.Op, *rpc.CallOptions) error); ok {
		r1 = rf(ctx, o, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TraceCode provides a mock function with given fields: ctx, id, body, resp
func (_m *RpcClient) TraceCode(ctx context.Context, id rpc.BlockID, body interface{}, resp interface{}) error {
	ret := _m.Called(ctx, id, body, resp)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockID, interface{}, interface{}) error); ok {
		r0 = rf(ctx, id, body, resp)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// TrustNetworkPeer provides a mock function with given fields: ctx, peerID
func (_m *RpcClient) TrustNetworkPeer(ctx context.Context, peerID string) error {
	ret := _m.Called(ctx, peerID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, peerID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// TrustNetworkPoint provides a mock function with given fields: ctx, address
func (_m *RpcClient) TrustNetworkPoint(ctx context.Context, address string) error {
	ret := _m.Called(ctx, address)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, address)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UseIpfsUrl provides a mock function with given fields: uri
func (_m *RpcClient) UseIpfsUrl(uri string) error {
	ret := _m.Called(uri)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(uri)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Validate provides a mock function with given fields: ctx, o
func (_m *RpcClient) Validate(ctx context.Context, o *codec.Op) error {
	ret := _m.Called(ctx, o)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *codec.Op) error); ok {
		r0 = rf(ctx, o)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type mockConstructorTestingTNewRpcClient interface {
	mock.TestingT
	Cleanup(func())
}

// NewRpcClient creates a new instance of RpcClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewRpcClient(t mockConstructorTestingTNewRpcClient) *RpcClient {
	mock := &RpcClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
